"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[44104],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(a),m=i,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||s;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<s;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},38610:(e,t,a)=>{a.d(t,{Z:()=>s});var n=a(67294),i=a(44996);const s=e=>n.createElement("div",null,n.createElement("p",{align:"center"},n.createElement("figure",null,n.createElement("img",{style:{width:e.width},alt:e.alt,src:(0,i.Z)(e.source)}),n.createElement("figcaption",{class:"image-caption",style:{fontStyle:"italic",opacity:.6,fontSize:"0.9rem"}},e.caption))))},92908:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(67294),i=a(39960);a(44996);const s=()=>n.createElement("span",{className:"in-blog-cta--divider"}," \u2192 "),o=()=>n.createElement("p",{className:"in-blog-cta-link-container"},n.createElement(i.Z,{className:"in-blog-cta--link",to:"https://e44cy1h4s0q.typeform.com/to/ycUzQa5A"},"We are in Beta (try it out)!"),n.createElement(s,null),n.createElement(i.Z,{className:"in-blog-cta--link",to:"https://discord.gg/rzdnErX"},"Join our community"),n.createElement(s,null),n.createElement(i.Z,{className:"in-blog-cta--link",to:"https://wasp-lang.notion.site/Founding-Engineer-at-Wasp-402274568afa4d7eb7f428f8fa2c0816"},"Work with us"))},46665:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(87462),i=(a(67294),a(3905)),s=(a(39960),a(44996),a(92908),a(70589),a(38610));const o={title:"Feature Release Announcement - Wasp Optimistic Updates",authors:["sodic"],image:"/img/opt-updates-banner.png",tags:["webdev","wasp","feature","optimistic","updates"]},r=void 0,l={permalink:"/blog/2022/11/30/optimistic-update-feature-announcement",editUrl:"https://github.com/wasp-lang/wasp/edit/release/web/blog/2022-11-30-optimistic-update-feature-announcement.md",source:"@site/blog/2022-11-30-optimistic-update-feature-announcement.md",title:"Feature Release Announcement - Wasp Optimistic Updates",description:"We\u2019re excited to announce that Wasp actions now feature native support for optimistic updates!",date:"2022-11-30T00:00:00.000Z",formattedDate:"November 30, 2022",tags:[{label:"webdev",permalink:"/blog/tags/webdev"},{label:"wasp",permalink:"/blog/tags/wasp"},{label:"feature",permalink:"/blog/tags/feature"},{label:"optimistic",permalink:"/blog/tags/optimistic"},{label:"updates",permalink:"/blog/tags/updates"}],readingTime:6.165,hasTruncateMarker:!0,authors:[{name:"Filip Sodi\u0107",title:"Founding Engineer @ Wasp",url:"https://github.com/sodic",email:"filip@wasp-lang.dev",imageURL:"https://github.com/sodic.png",key:"sodic"}],frontMatter:{title:"Feature Release Announcement - Wasp Optimistic Updates",authors:["sodic"],image:"/img/opt-updates-banner.png",tags:["webdev","wasp","feature","optimistic","updates"]},prevItem:{title:"Wasp Beta brings major IDE improvements",permalink:"/blog/2022/12/01/beta-ide-improvements"},nextItem:{title:"Permissions (access control) in web apps",permalink:"/blog/2022/11/29/permissions-in-web-apps"}},p={authorsImageUrls:[void 0]},c=[{value:"What are Optimistic Updates Anyway?",id:"what-are-optimistic-updates-anyway",level:2},{value:"A Wasp Todo App Without Optimistic Updates",id:"a-wasp-todo-app-without-optimistic-updates",level:2},{value:"Performing a Wasp Action Optimistically",id:"performing-a-wasp-action-optimistically",level:2},{value:"What Makes Optimistic Updates Difficult",id:"what-makes-optimistic-updates-difficult",level:2}],u={toc:c},d="wrapper";function m(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"We\u2019re excited to announce that Wasp actions now feature native support for optimistic updates!\nContinue reading to to find out what optimistic updates are and how Wasp implements them."),(0,i.kt)(s.Z,{alt:"Wasp TS support",source:"img/opt-updates-banner.png",mdxType:"ImgWithCaption"}),(0,i.kt)("h2",{id:"what-are-optimistic-updates-anyway"},"What are Optimistic Updates Anyway?"),(0,i.kt)("p",null,"Think about an interactive web app you use daily. It could be almost anything (e.g., Reddit, Youtube, Facebook). It almost certainly features UI elements you can interact with without refreshing the page, such as upvotes on Reddit or likes on Youtube."),(0,i.kt)("p",null,"All these small actions play out in the same manner. Let's look at Reddit upvotes as an example:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You click on the upvote button"),(0,i.kt)("li",{parentName:"ol"},"Your browser sends a request to the server to save the upvote"),(0,i.kt)("li",{parentName:"ol"},"The server saves your upvote to the database and sends a successful response to your browser"),(0,i.kt)("li",{parentName:"ol"},"Your browser receives the successful response and reflects the change in the UI (i.e., you see your upvote)")),(0,i.kt)("p",null,"The client\xa0",(0,i.kt)("em",{parentName:"p"},"waits"),"\xa0for the server's confirmation\xa0",(0,i.kt)("em",{parentName:"p"},"before"),"\xa0updating the UI because actions can sometimes fail. Well, at least that was the original idea."),(0,i.kt)("p",null,"These days, many popular websites update their UIs\xa0",(0,i.kt)("em",{parentName:"p"},"without waiting"),"\xa0for servers' responses. Most of the time, everything goes as expected: you click on an upvote, and the server returns a successful response a couple of seconds later (depending on how fast your connection is). Since programmers want their users to have a snappier experience, instead of waiting for a confirmation, they update the UI immediately (as if the action were successful) and then roll back if the server doesn't return a successful response (which rarely happens). This pattern of optimistically updating the UI before receiving the confirmation of success is called, you guessed it, an\xa0",(0,i.kt)("strong",{parentName:"p"},"Optimistic Update"),"."),(0,i.kt)("p",null,"Most popular modern websites use optimistic updates to some degree. As mentioned, Reddit uses them for upvotes and downvotes, Youtube uses them for likes, and Trello uses them when moving cards between lists."),(0,i.kt)("p",null,"Optimistic updates are a significant UX improvement, but since they introduce additional state (which can get out of sync with the server), they can be tricky to get right. Then there's also the issue of writing additional code for managing the cache and rolling back the changes if the request ends up failing. Luckily, we're here to help!"),(0,i.kt)("p",null,"Wasp recently added native support for optimistic updates, and the rest of this post demonstrates how to quickly set it up in your Wasp application."),(0,i.kt)("h2",{id:"a-wasp-todo-app-without-optimistic-updates"},"A Wasp Todo App Without Optimistic Updates"),(0,i.kt)("p",null,"To honor the tradition of demonstrating UIs using Todo apps, We'll show you how to improve the UX of toggling an item's status when working with a slow connection.\nBefore looking at our todo app in action, let's see how we've implemented it in Wasp."),(0,i.kt)("p",null,"These are the relevant declarations in our ",(0,i.kt)("inlineCode",{parentName:"p"},".wasp")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp",metastring:"title=main.wasp",title:"main.wasp"},'entity Task {=psl\n    id          Int     @id @default(autoincrement())\n    description String\n    isDone      Boolean @default(false)\npsl=}\n\n// A query for fetching all tasks.\nquery getTasks {\n  fn: import { getTasks } from "@server/queries.js",\n  entities: [Task]\n}\n\n\n// An action for updating the task\'s status.\naction updateTask {\n  fn: import { updateTask } from "@server/actions.js",\n  entities: [Task]\n}\n')),(0,i.kt)("p",null,"This is the query we use to fetch the tasks (together with their statuses):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=queries.js",title:"queries.js"},"export const getTasks = async (args, context) => {\n  return context.entities.Task.findMany()\n}\n")),(0,i.kt)("p",null,"Here's the action we use to update a task\u2019s status:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=actions.js",title:"actions.js"},"export const updateTask = async ({ id, isDone }, context) => {\n  return context.entities.Task.updateMany({\n    where: { id },\n    data: { isDone }\n  })\n}\n")),(0,i.kt)("p",null,"Finally, this is how our client uses this action to update a task:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"title=MainPage.js",title:"MainPage.js"},"import updateTask from '@wasp/queries'\n\n// ...\n\nfunction Task({ id, isDone, description }) {\n  return (\n    <div className=\"task\">\n      <label className=\"description\">\n        <input\n          type='checkbox' id={id}\n          checked={isDone}\n          onChange={\n            (e) => updateTask({ id, isDone: e.target.checked })\n          }\n        /><span>{description}</span></label>\n    </div>\n  )\n}\n")),(0,i.kt)("p",null,"Let's first see how updating a task looks when everything works as expected (i.e., we're on a fast connection):"),(0,i.kt)(s.Z,{alt:"Normal todo list",source:"img/optimistic-update-feature-announcement-normal.gif",mdxType:"ImgWithCaption"}),(0,i.kt)("p",null,"So far, so good! But what happens when our connection is not as fast?"),(0,i.kt)(s.Z,{alt:"Todo list with lag",source:"img/optimistic-update-feature-announcement-lag.gif",mdxType:"ImgWithCaption"}),(0,i.kt)("p",null,"Hmm, this isn't quite as smooth as we'd like it to be.\nThe user has to wait for several seconds before seeing their their changes reflected by the UI."),(0,i.kt)("p",null,"How can we improve it? Well, of course, we can optimistically update the checkbox!"),(0,i.kt)("h2",{id:"performing-a-wasp-action-optimistically"},"Performing a Wasp Action Optimistically"),(0,i.kt)("p",null,"To perform the ",(0,i.kt)("inlineCode",{parentName:"p"},"updateTask")," action optimistically, all we need to do is decorate the calling code on the client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{6-16,25} title=MainPage.js","{6-16,25}":!0,title:"MainPage.js"},"import updateTask from '@wasp/queries'\n\n// ...\n\nfunction Task({ id, isDone, description }) {\n  const updateTaskOptimistically = useAction(updateTask, {\n    optimisticUpdates: [{\n      // Addressing the query we want to update.\n      getQuerySpecifier: () => [getTasks],\n      // Telling Wasp how to update the addressed query using the new payload\n      // and the previously cached data.\n      updateQuery: ({ id, isDone }, oldTasks) => oldTasks.map(\n        task => task.id === id ? { ...task, isDone } : task\n      )\n    }]\n  })\n\n  return (\n    <div className=\"task\">\n      <label className=\"description\">\n        <input\n          type='checkbox' id={id}\n          checked={isDone}\n          onChange={\n            (e) => updateTaskOptimistically({ id, isDone: e.target.checked })\n          }\n        /><span>{description}</span></label>\n    </div>\n  )\n}\n")),(0,i.kt)("p",null,"Those are all the changes we need, the rest of the code (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"main.wasp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"queries.js")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"actions.js"),") remains the same. We won't describe the API in detail, but if you're curious, everything is covered by ",(0,i.kt)("a",{parentName:"p",href:"/docs/data-model/operations/actions#the-useaction-hook-and-optimistic-updates"},"our official docs"),"."),(0,i.kt)("p",null,"Finally, let's see how this version of the app looks in action:"),(0,i.kt)(s.Z,{alt:"Optimistically updated todo list",source:"img/optimistic-update-feature-announcement-fixed.gif",mdxType:"ImgWithCaption"}),(0,i.kt)("p",null,"Our app no longer waits for the server before rendering the changes. Instead, it updates the cache optimistically, continues waiting for the response, and rolls back the changes if the action fails (Wasp internally handles all of this). As previously mentioned, simple changes such as this one rarely fail. Therefore, most of the time, the user enjoys their snappier experience without ever knowing anything special is happening in the background."),(0,i.kt)("h2",{id:"what-makes-optimistic-updates-difficult"},"What Makes Optimistic Updates Difficult"),(0,i.kt)("p",null,"There's an old software engineering joke you're probably familiar with:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"There are only two hard things in Computer Science: cache invalidation and naming things.")),(0,i.kt)("p",null,"Optimistically updating a query involves plenty of meddling with the client-side cache, which is bound to come with a few gotchas. Examples include the answers to questions such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"What happens when an optimistically updated action fails?"),(0,i.kt)("li",{parentName:"ul"},"What happens when the user uses the optimistically updated data in a new action?"),(0,i.kt)("li",{parentName:"ul"},"What happens when the user performs a different action that affects the same cached data as the optimistically updated one?"),(0,i.kt)("li",{parentName:"ul"},"etc.")),(0,i.kt)("p",null,"Notice how Wasp users don't need to know about any of these issues when using our optimistic updates API. They only need to tell Wasp which query they wish to update and how, and Wasp takes care of the rest."),(0,i.kt)("p",null,"Wasp internally uses\xa0",(0,i.kt)("a",{parentName:"p",href:"https://tanstack.com/query/v4"},"React Query"),", an excellent asynchronous state management library we'll gladly recommend to anyone. While React Query does solve some of these problems and helps with some of the rest, we still had to implement quite a complex mechanism to fully cover all edge cases."),(0,i.kt)("p",null,"Describing this mechanism, although technically interesting, is beyond the scope of a feature announcement. But stay tuned because in a future blog post, we'll be taking a deep dive into the infrastructure Wasp uses to ensure optimistic updates are performed correctly and consistently."))}m.isMDXComponent=!0},70589:(e,t,a)=>{a.d(t,{ZP:()=>r});var n=a(87462),i=(a(67294),a(3905));const s={toc:[]},o="wrapper";function r(e){let{components:t,...a}=e;return(0,i.kt)(o,(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Wasp is a configuration language (DSL) for building full-stack web apps with less code and best practices that works alongside React and Node.js. We are on a mission to streamline web app development while empowering developers to continue using the power of code and their favorite tools. We are backed by Y Combinator and engineers from Airbnb, Facebook, and Lyft.")))}r.isMDXComponent=!0}}]);