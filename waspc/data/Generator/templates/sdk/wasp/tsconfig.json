{
  "compilerOptions": {
    /* Basic opitions */
    "target": "es2022",
    "jsx": "preserve",
    "lib": [
      "esnext",
      "dom",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "allowJs": true,
    "rootDir": ".",
    "outDir": "dist", 

    /* Strictness and type checking */
    /*
      User code was compiled uses strict: true, so we know we can use it
      here as well. We override some of strict's options because our code
      doesn't work with them enabled. This only makes SDK ruleset more
      permissive than the user's ruleset, so we can sefely include users's
      code inside the SDK.
      Reference: https://github.com/wasp-lang/wasp/issues/1938
    */
    "strict": true,
    "useUnknownInCatchVariables": false, 
    "noImplicitAny": false,
    "strictPropertyInitialization": false,
    // The following two properties are disabled because we don't
    // yet want to force user code to use them.
    // Reference: https://github.com/wasp-lang/wasp/issues/2655
    "noUncheckedIndexedAccess": false,
    "noImplicitOverride": false,

    /* DX */
    "declaration": true, // Allows users to consume the SDK as a library, enables autocomplete
    "declarationMap": true, // Makes go-to-defintion go to source instead of type definition
    "sourceMap": true, // Needed for debugging

    /* Modules */
    "module": "preserve",
    "esModuleInterop": true,
    // TODO: Enable this once we enable it for users: https://github.com/wasp-lang/wasp/issues/2654
    "resolveJsonModule": false,
    /*
       The `isolatedModules` flag tells typescript to throw errors on
       code that doesn't work with bundlers:
         - The user code must enable it because Wasp bundles server code and
        web app code, which import user code directly.
         - The SDK code must disable it because parts of it rely on such
        features. Even though the SDK is eventually bunlded, it's first built
        with TSC. These features therefore don't cause problems.
      More details in https://github.com/wasp-lang/wasp/issues/2150
    */
    "isolatedModules": false,
    // `verbatimModuleSyntax` is disabled because we don't yet want to
    // force user code into using `type` imports.
    "verbatimModuleSyntax": false, 
    "moduleDetection": "force",
    /*
      The correct `moduleResolution` option is `bundler` because:

      - We want to allow users to use extensionless and directory imports.
      - We want users to import stuff from the SDK with `wasp/something`,
        and we don't want to do extra processing on those imports (for now).

      The above two points force us to bundle user code and, since user code
      is copied into the SDK code (into the `src/` dir), they force us to bundle
      the SDK too.

      We currently bundle the SDK in a very hacky way (i.e., we do it indirectly
      while bundling the server and client): https://github.com/wasp-lang/wasp/issues/2150
      Regardless of how we do it, the SDK code is eventually bundled and this 
      `tsconfig.json` must reflect that.

      Unfortunatley, we can't set `"moduleResolution": "bundler"` due to an
      issue with stitches: https://github.com/stitchesjs/stitches/issues/1160.

      "Node10" models the resolution of Node.js <= 12, but it's also a passable
      approximation of how most bundlers do module resolution. It allows all the
      bundler features we want to support. Since we can't have "bundler",
      "node10" is the next best thing.
      Source: https://www.typescriptlang.org/docs/handbook/modules/theory.html#module-resolution

      We should change this to "bundler" when we move away from stitches.
    */
    "moduleResolution": "node10",
    "types": [
      /*
        This is needed to properly support Vitest testing with jest-dom matchers.
        Types for jest-dom are not recognized automatically and Typescript complains
        about missing types e.g. when using `toBeInTheDocument` and other matchers.
      */
      "@testing-library/jest-dom"
    ],
    /*
      The `incremental` option enables faster SDK compilation, less Vite HMR
      messages and it prevent unnecessary full-page reloads when using Vite HMR.
      While this is great, we still want to dig deeper at some point to understand
      better why Vite HMR misbehaves when the SDK is recompiled:
      https://github.com/wasp-lang/wasp/issues/1934 
    */
    "incremental": true,
  },
  "include": [
    "."
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
